#! /usr/bin/env python3

"""
generate_alarms.py

Reads alarm definitions from a CSV file and generates C code for the alarm engine.
This version generates a header and a .c.inc file to be directly included
into a single application, avoiding linker issues.
"""

import pandas as pd
import numpy as np
import os

# --- Configuration ---
CSV_INPUT_FILE = os.path.join('scripts', 'alarms.csv')
C_CONFIG_HEADER_OUTPUT_FILE = os.path.join('alarm_engine', 'alarm_config.h')
C_LOGIC_INCLUDE_OUTPUT_FILE = os.path.join('alarm_engine', 'alarm_logic.c.inc')


# --- Mappings ---
CONDITION_MAP = {
    "CONDITION_EQUAL": "==",
    "CONDITION_GREATER_THAN": ">",
    "CONDITION_LESS_THAN": "<",
}

ALARM_TYPE_MAP = {
    "INFO": "ALARM_TYPE_INFO",
    "WARN": "ALARM_TYPE_WARN",
    "CRITICAL": "ALARM_TYPE_CRITICAL",
}

# --- Helper Functions ---

def format_c_string(value):
    """Formats a string for inclusion in C code by escaping characters."""
    if not isinstance(value, str):
        return ""
    return value.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n')

def format_trigger_value(value):
    """Formats a trigger value from the CSV for use in a C comparison."""
    if isinstance(value, np.floating):
        value = value.item()
    if isinstance(value, str):
        val_upper = value.strip().upper()
        if val_upper == 'TRUE':
            return 'true'
        if val_upper == 'FALSE':
            return 'false'
    return str(value)

def generate_config_header_file(alarm_df):
    """Generates the content for the C header file (alarm_config.h)."""
    valid_alarms_df = alarm_df.dropna(subset=['Alarm ID'])
    num_alarms = len(valid_alarms_df)
    
    content = []
    content.append("// alarm_config.h - AUTO-GENERATED by generate_alarms.py. DO NOT EDIT.")
    content.append("")
    content.append("#ifndef ALARM_CONFIG_H")
    content.append("#define ALARM_CONFIG_H")
    content.append("")
    content.append("#include <stdbool.h>")
    content.append("")
    content.append(f"#define ALARM_COUNT {num_alarms}")
    content.append("")
    content.append("typedef enum {")
    content.append("    ALARM_TYPE_INFO,")
    content.append("    ALARM_TYPE_WARN,")
    content.append("    ALARM_TYPE_CRITICAL")
    content.append("} AlarmType;")
    content.append("")
    content.append("typedef struct {")
    content.append("    const int id;")
    content.append("    const AlarmType type;")
    content.append("    const char* label;")
    content.append("    const char* eventMessage;")
    content.append("    const int trigger_delay_seconds;")
    content.append("} AlarmInfo;")
    content.append("")
    content.append("extern const AlarmInfo alarmInfo[ALARM_COUNT];")
    content.append("")
    content.append("#endif // ALARM_CONFIG_H")

    return "\n".join(content)

def generate_logic_include_file(alarm_df):
    """Generates the C code to be included directly into the main application."""
    valid_alarms_df = alarm_df.dropna(subset=['Alarm ID'])

    content = []
    content.append("// alarm_logic.c.inc - AUTO-GENERATED by generate_alarms.py. DO NOT EDIT.")
    content.append("// This file is designed to be #included directly into sysAlertMon.c")
    content.append("")
    
    # --- AlarmInfo Array Definition ---
    content.append("const AlarmInfo alarmInfo[ALARM_COUNT] = {")
    
    for index, row in valid_alarms_df.iterrows():
        alarm_id = int(row['Alarm ID'])
        alarm_type = ALARM_TYPE_MAP.get(row['Alarm Type'].strip().upper(), "ALARM_TYPE_INFO")
        label = format_c_string(row['Label'])
        message = format_c_string(row['Event Message'])
        delay = int(row['TRIGGER_DELAY'])
        
        # We need to ensure the order matches the enum/ID, or look it up.
        # Assuming the CSV is sorted by Alarm ID starting from 0.
        content.append(f'    /* {alarm_id} */ {{ {alarm_id}, {alarm_type}, "{label}", "{message}", {delay} }},')
    
    content.append("};")
    content.append("")

    # --- Main Evaluation Function ---
    content.append("void check_alarms(alert_data_t* output_alert_data)")
    content.append("{")
    content.append("    bool condition = false;")
    content.append("")

    for index, row in valid_alarms_df.iterrows():
        if pd.isna(row['Alarm ID']):
            continue

        alarm_id = int(row['Alarm ID'])
        
        if row['Alarm Type'].strip().upper() == 'INFO' and row['Label'].strip().upper() == 'SPARE':
            content.append(f"    // --- Alarm {alarm_id}: SPARE ---")
            content.append(f"    update_alarm_state(output_alert_data, {alarm_id}, false);")
            content.append("")
            continue
            
        content.append(f"    // --- Alarm {alarm_id}: {row['Label'].strip()} ---")
        
        op1 = CONDITION_MAP.get(row['Conditional1'].strip())
        val1 = format_trigger_value(row['TrigValue1'])
        var1 = row['Trigger Var1'].strip()
        
        if not op1 or not var1:
            content.append(f"    condition = false; // Invalid or missing first condition")
        else:
            condition_str1 = f"({var1} {op1} {val1})"
            
            if pd.notna(row['Operator']) and row['Operator'].strip().upper() == 'AND':
                op2 = CONDITION_MAP.get(row['Conditional2'].strip())
                val2 = format_trigger_value(row['TrigValue2'])
                var2 = row['Trigger Var2'].strip()
                
                if not op2 or not var2:
                     condition_str2 = "false"
                else:
                    condition_str2 = f"({var2} {op2} {val2})"
                
                content.append(f"    condition = {condition_str1} && {condition_str2};")
            else:
                content.append(f"    condition = {condition_str1};")

        content.append(f"    update_alarm_state(output_alert_data, {alarm_id}, condition);")
        content.append("")

    content.append("}")
    
    return "\n".join(content)


def main():
    """Main execution function."""
    print("--- Starting Alarm Code Generation ---")

    if not os.path.exists(CSV_INPUT_FILE):
        print(f"ERROR: Input file not found at '{CSV_INPUT_FILE}'")
        return 1

    try:
        df = pd.read_csv(CSV_INPUT_FILE)
        df.sort_values(by='Alarm ID', inplace=True) # Ensure data is sorted for array initialization
        original_rows = len(df)
        df = df.dropna(subset=['Alarm ID'])
        if len(df) < original_rows:
            print(f"Note: Skipped {original_rows - len(df)} rows with empty 'Alarm ID'.")
        print(f"Successfully read and validated {len(df)} alarm definitions from '{CSV_INPUT_FILE}'.")
    except Exception as e:
        print(f"ERROR: Failed to read or parse '{CSV_INPUT_FILE}': {e}")
        return 1
        
    # Generate config header file
    header_output_path = os.path.abspath(C_CONFIG_HEADER_OUTPUT_FILE)
    print(f"Generating config header file: '{header_output_path}'...")
    header_content = generate_config_header_file(df)
    with open(header_output_path, 'w') as f:
        f.write(header_content)
    print("Config header file generated successfully.")

    # Generate logic include file
    logic_output_path = os.path.abspath(C_LOGIC_INCLUDE_OUTPUT_FILE)
    print(f"Generating logic include file: '{logic_output_path}'...")
    logic_content = generate_logic_include_file(df)
    with open(logic_output_path, 'w') as f:
        f.write(logic_content)
    print("Logic include file generated successfully.")
    
    print("\n--- Alarm Code Generation Complete ---")

if __name__ == "__main__":
    main() 